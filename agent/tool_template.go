package agent

// This file provides templates and utilities for code generation of type-safe tools.
// Use go generate to automatically create tool wrappers.
//
// Usage:
//
// 1. Define your tool handler with a comment directive:
//
//    //go:generate go run github.com/hlfshell/gogentic/agent/cmd/gentool -type=WeatherTool
//    type WeatherTool struct{}
//
//    func (w WeatherTool) Execute(ctx context.Context, location string) (WeatherData, error) {
//        return fetchWeather(location), nil
//    }
//
// 2. Run: go generate ./...
//
// 3. Generated code will create a Tool implementation automatically

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"strings"
	"text/template"
)

// ToolTemplate is the template for generating tool wrappers
const ToolTemplate = `// Code generated by gentool. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"github.com/hlfshell/gogentic/agent"
)

// {{.Name}}Wrapper wraps {{.Name}} to implement agent.Tool
type {{.Name}}Wrapper struct {
	impl {{.Name}}
	name string
	description string
	parameters map[string]interface{}
}

// New{{.Name}} creates a new tool wrapper for {{.Name}}
func New{{.Name}}(name, description string, parameters map[string]interface{}) agent.Tool {
	return agent.NewTypedTool(
		name,
		description,
		parameters,
		func(ctx context.Context, args agent.Arguments) ({{.ReturnType}}, error) {
			impl := {{.Name}}{}
			{{range .Args}}
			{{.Name}}, err := args.Get{{.TypeName}}("{{.Name}}")
			if err != nil {
				return {{$.ZeroValue}}, err
			}
			{{end}}
			return impl.Execute(ctx{{range .Args}}, {{.Name}}{{end}})
		},
	)
}
`

// ToolGenerator generates tool wrappers from type definitions
type ToolGenerator struct {
	Package    string
	Name       string
	ReturnType string
	ZeroValue  string
	Args       []ArgInfo
}

// ArgInfo represents a function argument
type ArgInfo struct {
	Name     string
	Type     string
	TypeName string // Capitalized for method name like GetString
}

// GenerateToolWrapper generates a tool wrapper for the given type
func GenerateToolWrapper(typeName, packageName, filePath string) (string, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return "", fmt.Errorf("failed to parse file: %w", err)
	}

	var targetType *ast.TypeSpec
	ast.Inspect(node, func(n ast.Node) bool {
		if typeSpec, ok := n.(*ast.TypeSpec); ok {
			if typeSpec.Name.Name == typeName {
				targetType = typeSpec
				return false
			}
		}
		return true
	})

	if targetType == nil {
		return "", fmt.Errorf("type %s not found in %s", typeName, filePath)
	}

	// Find the Execute method
	var executeFunc *ast.FuncDecl
	ast.Inspect(node, func(n ast.Node) bool {
		if funcDecl, ok := n.(*ast.FuncDecl); ok {
			if funcDecl.Name.Name == "Execute" {
				// Check if it's a method of our type
				if funcDecl.Recv != nil && len(funcDecl.Recv.List) > 0 {
					if starExpr, ok := funcDecl.Recv.List[0].Type.(*ast.StarExpr); ok {
						if ident, ok := starExpr.X.(*ast.Ident); ok && ident.Name == typeName {
							executeFunc = funcDecl
							return false
						}
					} else if ident, ok := funcDecl.Recv.List[0].Type.(*ast.Ident); ok && ident.Name == typeName {
						executeFunc = funcDecl
						return false
					}
				}
			}
		}
		return true
	})

	if executeFunc == nil {
		return "", fmt.Errorf("Execute method not found for type %s", typeName)
	}

	gen := &ToolGenerator{
		Package: packageName,
		Name:    typeName,
		Args:    []ArgInfo{},
	}

	// Parse function signature
	if executeFunc.Type.Params != nil {
		for i, field := range executeFunc.Type.Params.List {
			// Skip context.Context (first parameter)
			if i == 0 {
				continue
			}

			for _, name := range field.Names {
				argType := exprToString(field.Type)
				gen.Args = append(gen.Args, ArgInfo{
					Name:     name.Name,
					Type:     argType,
					TypeName: capitalize(argType),
				})
			}
		}
	}

	// Parse return type
	if executeFunc.Type.Results != nil && len(executeFunc.Type.Results.List) > 0 {
		// First return value is the result type, second is error
		gen.ReturnType = exprToString(executeFunc.Type.Results.List[0].Type)
		gen.ZeroValue = zeroValueFor(gen.ReturnType)
	}

	// Generate code from template
	tmpl, err := template.New("tool").Parse(ToolTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, gen); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.String(), nil
}

// exprToString converts an ast.Expr to a string representation
func exprToString(expr ast.Expr) string {
	switch e := expr.(type) {
	case *ast.Ident:
		return e.Name
	case *ast.StarExpr:
		return "*" + exprToString(e.X)
	case *ast.ArrayType:
		return "[]" + exprToString(e.Elt)
	case *ast.SelectorExpr:
		return exprToString(e.X) + "." + e.Sel.Name
	default:
		return ""
	}
}

// capitalize capitalizes the first letter of a string
func capitalize(s string) string {
	if s == "" {
		return ""
	}
	// Handle common type names
	switch s {
	case "string":
		return "String"
	case "int", "int64", "int32", "int16", "int8":
		return "Int"
	case "float64", "float32":
		return "Float"
	case "bool":
		return "Bool"
	default:
		return strings.ToUpper(s[:1]) + s[1:]
	}
}

// zeroValueFor returns the zero value for a given type
func zeroValueFor(typeName string) string {
	switch typeName {
	case "string":
		return `""`
	case "int", "int64", "int32", "int16", "int8",
		"uint", "uint64", "uint32", "uint16", "uint8",
		"float64", "float32":
		return "0"
	case "bool":
		return "false"
	default:
		// For struct types, return zero value constructor
		return typeName + "{}"
	}
}
